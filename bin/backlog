#!/usr/bin/env node
import { readFile, readdir, writeFile } from "node:fs/promises";
import path from "node:path";

function printUsage(message) {
    if (message) {
        console.error(message);
    }
    console.error(
        "Usage: backlog task edit <task-id> [options]\n" +
            "Options:\n" +
            "  -s, --status <status>\n" +
            "  --append-notes <text>\n" +
            "  --check-ac <number>\n" +
            "  --uncheck-ac <number>",
    );
    process.exit(1);
}

function formatTimestamp(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    const hours = String(date.getHours()).padStart(2, "0");
    const minutes = String(date.getMinutes()).padStart(2, "0");
    return `${year}-${month}-${day} ${hours}:${minutes}`;
}

async function resolveTaskFile(taskId) {
    const tasksDir = path.join(process.cwd(), "backlog", "tasks");
    const entries = await readdir(tasksDir);
    const target = entries.find((entry) =>
        entry.startsWith(`${taskId} `) || entry.startsWith(`${taskId}-`) || entry.startsWith(`${taskId} -`),
    );
    if (!target) {
        throw new Error(`Unable to locate task file for ${taskId}`);
    }
    return path.join(tasksDir, target);
}

function updateFrontmatter(content, updates) {
    if (!content.startsWith("---")) {
        throw new Error("Task file is missing frontmatter");
    }
    const endIndex = content.indexOf("\n---", 3);
    if (endIndex === -1) {
        throw new Error("Task file frontmatter is malformed");
    }
    const frontmatter = content.slice(3, endIndex).split("\n").map((line) => line.trimEnd());
    while (frontmatter.length && frontmatter[0] === "") {
        frontmatter.shift();
    }
    const nextFrontmatter = frontmatter.map((line) => {
        if (line.startsWith("status:") && updates.status) {
            return `status: ${updates.status}`;
        }
        if (line.startsWith("updated_date:")) {
            return `updated_date: '${updates.updatedDate}'`;
        }
        return line;
    });
    if (!nextFrontmatter.some((line) => line.startsWith("updated_date:"))) {
        nextFrontmatter.push(`updated_date: '${updates.updatedDate}'`);
    }
    const rebuilt = `---\n${nextFrontmatter.join("\n")}\n---${content.slice(endIndex + 4)}`;
    return rebuilt;
}

function appendNotes(content, notes) {
    if (!notes.length) {
        return content;
    }
    const marker = "<!-- SECTION:NOTES:END -->";
    const beginMarker = "<!-- SECTION:NOTES:BEGIN -->";
    const beginIndex = content.indexOf(beginMarker);
    const endIndex = content.indexOf(marker);
    if (beginIndex === -1 || endIndex === -1 || endIndex < beginIndex) {
        throw new Error("Unable to locate Implementation Notes section");
    }
    const before = content.slice(0, endIndex).replace(/\s*$/, "\n");
    const after = content.slice(endIndex);
    const normalized = notes
        .map((note) => {
            const trimmed = note.trim();
            if (!trimmed) {
                return null;
            }
            return trimmed.startsWith("$") ? trimmed : `$${trimmed}`;
        })
        .filter(Boolean);
    if (!normalized.length) {
        return before + after;
    }
    const insertion = `${normalized.join("\n\n")}\n`;
    return `${before}${insertion}${after}`;
}

function updateAcceptanceCriteria(content, { checkAc, uncheckAc }) {
    if (!checkAc.length && !uncheckAc.length) {
        return content;
    }
    const beginMarker = "<!-- AC:BEGIN -->";
    const endMarker = "<!-- AC:END -->";
    const beginIndex = content.indexOf(beginMarker);
    const endIndex = content.indexOf(endMarker);
    if (beginIndex === -1 || endIndex === -1 || endIndex < beginIndex) {
        throw new Error("Unable to locate Acceptance Criteria section");
    }
    const sectionStart = beginIndex + beginMarker.length;
    const section = content.slice(sectionStart, endIndex);
    const lines = section.split("\n");
    const acLinePositions = [];
    lines.forEach((line, index) => {
        const trimmed = line.trimStart();
        if (/^- \[[ xX]\]/.test(trimmed)) {
            acLinePositions.push(index);
        }
    });
    const toggle = (targets, mark) => {
        targets.forEach((target) => {
            const position = acLinePositions[target - 1];
            if (position === undefined) {
                throw new Error(`Acceptance criteria index ${target} not found`);
            }
            lines[position] = lines[position].replace(/- \[[ xX]\]/, `- [${mark}]`);
        });
    };
    toggle(checkAc, "x");
    toggle(uncheckAc, " ");
    const updatedSection = lines.join("\n");
    return `${content.slice(0, sectionStart)}${updatedSection}${content.slice(endIndex)}`;
}

async function editTask(taskId, { status, appendNotes: notes, checkAc, uncheckAc }) {
    const filePath = await resolveTaskFile(taskId);
    let content = await readFile(filePath, "utf8");
    const updatedDate = formatTimestamp(new Date());
    content = updateFrontmatter(content, { status, updatedDate });
    content = updateAcceptanceCriteria(content, { checkAc, uncheckAc });
    content = appendNotes(content, notes);
    await writeFile(filePath, content, "utf8");
}

async function main() {
    const args = process.argv.slice(2);
    if (args.length < 3) {
        printUsage();
    }
    const [resource, command, taskId, ...rest] = args;
    if (resource !== "task" || command !== "edit") {
        printUsage();
    }
    if (!taskId) {
        printUsage("Task id is required");
    }
    let status = null;
    const appendNotes = [];
    const checkAc = [];
    const uncheckAc = [];
    for (let index = 0; index < rest.length; index += 1) {
        const arg = rest[index];
        if (arg === "-s" || arg === "--status") {
            const value = rest[index + 1];
            if (!value) {
                printUsage("Status value is required");
            }
            status = value;
            index += 1;
        } else if (arg === "--append-notes") {
            const value = rest[index + 1];
            if (!value) {
                printUsage("Note value is required");
            }
            appendNotes.push(value);
            index += 1;
        } else if (arg === "--check-ac" || arg === "--uncheck-ac") {
            const value = rest[index + 1];
            if (!value) {
                printUsage(`Acceptance criteria index required for ${arg}`);
            }
            const parsed = Number.parseInt(value, 10);
            if (!Number.isInteger(parsed) || parsed < 1) {
                printUsage(`Invalid acceptance criteria index: ${value}`);
            }
            if (arg === "--check-ac") {
                checkAc.push(parsed);
            } else {
                uncheckAc.push(parsed);
            }
            index += 1;
        } else {
            printUsage(`Unknown option ${arg}`);
        }
    }
    if (!appendNotes.length && !status && !checkAc.length && !uncheckAc.length) {
        printUsage("Nothing to update");
    }
    try {
        await editTask(taskId, { status, appendNotes, checkAc, uncheckAc });
    } catch (error) {
        console.error(error instanceof Error ? error.message : error);
        process.exit(1);
    }
}

main();
